#!/usr/bin/env node
const PROGRAM_NAME = process.argv[1].replace(/.*\//, "")

console.log(buildRemappings(deduplicate(buildDependencyTree("."))).join("\n"))

// builds a in memory representation of the projects dependency tree
//
// A node in the tree looks like this:
//
//   {
//     name: "",
//     path: "",
//     hash: "",
//     deps: []
//   }
function buildDependencyTree(prefix) {
  const lib = `${prefix}/${normalize(process.env.DAPP_LIB)}`
  return {
    name: prefix.split("/").pop(),
    path: normalize(`${prefix}/${normalize(process.env.DAPP_SRC)}`),
    hash: hash(prefix),
    deps: ls(lib).map(p => buildDependencyTree(`${lib}/${p}`))
  }
}

// walk tree and build remappings
function buildRemappings(pkg) {

  let implicits = []
  if (process.env.DAPP_ALLOW_TRANSITIVE_IMPORTS == "1") {
    // get the names of the direct dependencies
    const directs = pkg.deps.map(p => p.name)
    // get the transitive deps with exactly one version that are not direct deps
    const uniques = Object.entries(pkg.deps.reduce(buildVersionMap, {}))
                          .filter(([name, vs]) => vs.size == 1 && !directs.includes(name))
    // build remappings that allow importing these deps from `pkg`
    const paths = mapHashes(pkg)
    implicits = uniques.map(([name, v]) => `${pkg.path}/:${name}/=${paths[([...v][0])]}/`)
  }

  const remappings = pkg.deps.map(dep => `${pkg.path}/:${dep.name}/=${dep.path}/`)
  return pkg.deps.map(buildRemappings).concat(remappings).concat(implicits).flat()
}

// walk tree and rewrite paths so that all packages with the same hash have the same path
function deduplicate(pkg) {
  const mapping = mapHashes(pkg)
  const go = p => ({ ...p, path: mapping[p.hash], deps: p.deps.map(go) })
  return go(pkg)
}

// walk tree and build a mapping from hash => path
function mapHashes(pkg) {
  const go = (mapping, dep) => {
    // we collect the shortest path (aka closest to the root) for each dep
    if (mapping[dep.hash] == undefined || dep.path.length < mapping[dep.hash].length) {
      mapping[dep.hash] = dep.path
    }

    return dep.deps.reduce(go, mapping)
  }
  return pkg.deps.reduce(go, { [pkg.hash]: pkg.path })
}

// folds over a dependency tree with map as the accumlator and builds a mapping
// from package name to a set of discovered package verions
function buildVersionMap(map, pkg) {
  const update = (map, dep) => {
    map[dep.name] == undefined
      ? map[dep.name] = new Set([dep.hash])
      : map[dep.name].add(dep.hash)
    return map
  }

  return pkg.deps.reduce(update, update(map, pkg))
}

// strip the leading `.` or `./` from a path
function normalize(path) {
  return path.replace(/^\.\//, "").replace(/^\//, "")
}

// computes the hash of the contents of a given directory, uses the git hash if
// availalbe (because it's faster), or falls back to a sha256sum of the directory contents if needed
function hash(dir) {
  if (ls(dir).includes(".git")) {
    return run("git", ["-C", dir, "rev-parse", "HEAD"]).trim()
  } else {
    return run("bash", ["-c", `rg --files ${dir} | sort | xargs sha256sum | sha256sum | cut -d' ' -f1`]).trim()
  }
}

function ls(dir) {
  try {
    return require("fs").readdirSync(dir).sort()
  } catch (error) {
    return []
  }
}

function run(cmd, args) {
  return require("child_process").execFileSync(cmd, args, {
    encoding: "utf-8"
  })
}
